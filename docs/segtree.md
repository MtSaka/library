## 概要
完全二分木の実装です。モノイドについての区間に対する演算が$O(\log N)$で処理できます。
実装では木を1-indexedで表現しています。

## 使い方
* `segtree<S,op,e>seg(N)`:サイズ`N`で初期化する、ここで`S`は型、`op`は二項演算、`e`はモノイドの単位元である。また、opとeはそれぞれ関数である。計算量は$O(N)$  
* `segtree<S,op,e>seg(V)`:配列`V`で初期化する。`S`,`op`,`e`は上と同じく。`N=V.size()`として、計算量は$O(N)$  
* `set(p,x)`:`p`番目の要素を`x`に変更する。この時、0-indexedで表現している。計算量は$O(\log N)$
* `operator[p]`:`p`番目の要素を返す。(0-indexed)計算量は$O(1)$  
* `query(l,r)`:区間$[l,r)$に対しての演算の結果を返す。`l`,`r`は0-indexedで表現している。計算量は$O(\log N)$  
* `all_query()`:全体に対しての演算の結果を返す。計算量は$O(1)$  
* `find_right(l,F)`:区間$[l,x)$に対して$F(x)$が$false$を返す、最小の$x$を返す。存在しないときは$N$を返す。計算量は$O(\log N)$
* `find_left(r,F)`:区間$[x,r)$に対して$F(x)$が$false$を返す、最大の$x$を返す。存在しないときは$-1$を返す。計算量は$O(\log N)$